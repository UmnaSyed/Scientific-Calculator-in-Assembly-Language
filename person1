INCLUDE Irvine32.inc

.data

; ---------------- MATRIX ADDITION ----------------
msgRows BYTE "Enter number of rows (max 3): ",0
msgCols BYTE "Enter number of columns (max 3): ",0
msgA BYTE "Enter Matrix A elements: ",0
msgB BYTE "Enter Matrix B elements: ",0
msgResult BYTE "Result C (A + B): ",0

MatrixA SDWORD 9 DUP(?)    
MatrixB SDWORD 9 DUP(?)
MatrixC SDWORD 9 DUP(?)

rows DWORD ?
cols DWORD ?
totalElements DWORD ?

; ---------------- MULTIPLICATION ----------------
msgNum1 BYTE "Enter first number: ",0
msgNum2 BYTE "Enter second number: ",0
msgResultMul BYTE "Multiplication result: ",0
product SDWORD ?

; ---------------- POWER ----------------
msgBase        BYTE "Enter base: ",0
msgExponent    BYTE "Enter exponent: ",0
msgResultPow   BYTE "Power result: ",0
msgFraction    BYTE "Fraction form: 1/",0
msgDecimal     BYTE "Decimal form: ",0
msgOne         BYTE "1",0
msgNegativeOne BYTE "-1",0

base           SDWORD ?
exponent       SDWORD ?
result         SDWORD 1
temp           SDWORD ?
decimalResult  REAL8 ?
msgOverflow BYTE "Error! Overflow.",0

; ---------------- DIVISION ----------------
msgDividend BYTE "Enter dividend: ",0
msgDivisor BYTE "Enter divisor: ",0
msgQuotient BYTE "Quotient: ",0
msgRemainder BYTE "Remainder: ",0
msgError BYTE "Error: Division by zero!",0
quotient SDWORD ?
remainder SDWORD ?

; ---------------- NPR ----------------
msgN BYTE "Enter n (total items): ",0
msgR BYTE "Enter r (selected items): ",0
msgResultNPR BYTE "nPr result: ",0
msgErrorNPR BYTE "Error: r cannot be greater than n!",0
n_value DWORD ?
r_value DWORD ?
resultNPR DWORD 1

; ---------------- MENU ----------------
menu BYTE 0Dh,0Ah,
      "1. Matrix Addition",0Dh,0Ah,
      "2. Integer Multiplication",0Dh,0Ah,
      "3. Power",0Dh,0Ah,
      "4. Division",0Dh,0Ah,
      "5. nPr (Permutation)",0Dh,0Ah,
      "0. Exit",0Dh,0Ah,
      "Enter choice: ",0

.code
main PROC

MenuStart:
    mov edx, OFFSET menu
    call WriteString
    call ReadInt

    cmp eax, 1
    je doMatrix

    cmp eax, 2
    je doMult

    cmp eax, 3
    je doPower

    cmp eax, 4
    je doDivision

    cmp eax, 5
    je doNPR

    cmp eax, 0
    je exitProgram

    jmp MenuStart

doMatrix:
    call MatrixAddition
    jmp MenuStart

doMult:
    call Multiplication
    jmp MenuStart

doPower:
    call PowerCalculation
    jmp MenuStart

doDivision:
    call DivisionOperation
    jmp MenuStart

doNPR:
    call PermutationCalculation
    jmp MenuStart

exitProgram:
    exit

main ENDP

; ---------------- MATRIX ADDITION ----------------
MatrixAddition PROC

      ; for inputting rows
    mov edx, OFFSET msgRows
    call WriteString
    call ReadInt
    mov rows, eax

    ; for inputting columns
    mov edx, OFFSET msgCols
    call WriteString
    call ReadInt
    mov cols, eax

    ; finding totalElements = rows * cols
    mov eax, rows
    mul cols      
    mov totalElements, eax
    mov ecx, totalElements  

    ; inputting matrix A
    mov edx, OFFSET msgA
    call WriteString
    call Crlf

    mov esi, OFFSET MatrixA  

 ReadA:
    call ReadInt
    mov [esi], eax
    add esi, 4
    loop ReadA

    ; matrix B
    mov edx, OFFSET msgB
    call WriteString
    call Crlf

    mov ecx, totalElements  
    mov esi, OFFSET MatrixB 

ReadB:
    call ReadInt
    mov [esi], eax
    add esi, 4
    loop ReadB

    ; Addition
    mov ecx, totalElements  
    mov esi, OFFSET MatrixA
    mov edi, OFFSET MatrixB
    mov ebx, OFFSET MatrixC

AddLoop:
    mov eax, [esi]
    add eax, [edi]
    mov [ebx], eax

    add esi, 4
    add edi, 4
    add ebx, 4
    loop AddLoop

    ; Display result
    mov edx, OFFSET msgResult
    call WriteString
    call Crlf

    mov ecx, rows   
    mov edx, cols   

    mov esi, OFFSET MatrixC

PrintRows:
    push ecx
    mov ecx, edx   

PrintCols:
    mov eax, [esi]
    call WriteInt

    mov al, ' '
    call WriteChar

    add esi, 4
    loop PrintCols

    call Crlf
    pop ecx
    loop PrintRows

    ret
MatrixAddition ENDP

; ---------------- MULTIPLICATION ----------------
Multiplication PROC
    mov edx, OFFSET msgNum1
    call WriteString
    call ReadInt
    mov ebx, eax

    mov edx, OFFSET msgNum2
    call WriteString
    call ReadInt
    mov ecx, eax

    mov eax, ebx
    imul ecx
    mov product, eax    

    mov edx, OFFSET msgResultMul
    call WriteString
    call WriteInt
    call Crlf

    ret
Multiplication ENDP

; ---------------- POWER ----------------
PowerCalculation PROC

    mov  edx, OFFSET msgBase
    call WriteString
    call ReadInt
    mov  base, eax

    mov  edx, OFFSET msgExponent
    call WriteString
    call ReadInt
    mov  exponent, eax

    cmp  eax, 0
    jne  NotZero
    mov  eax, 1
    jmp  DisplayIntegerResult

NotZero:
    mov  eax, exponent
    cmp  eax, 0
    jg   PositiveExponent
    jl   NegativeExponent

PositiveExponent:
    mov  eax, 1
    mov  ecx, exponent
    mov  ebx, base

PositivePowerLoop:
    imul ebx
    loop PositivePowerLoop
    jmp  DisplayIntegerResult

NegativeExponent:
    mov  eax, exponent
    neg  eax
    mov  ecx, eax
    mov  ebx, base

    cmp  ebx, 1
    je   BaseIsOne
    cmp  ebx, -1
    je   BaseIsNegativeOne

    mov  eax, 1
    mov  edx, 0

CalculatePositivePower:
    imul ebx
    jo   OverflowDetected
    loop CalculatePositivePower

    mov  result, eax

    mov  edx, OFFSET msgResultPow
    call WriteString
    call Crlf

    mov  edx, OFFSET msgFraction
    call WriteString
    mov  eax, result
    call WriteInt
    call Crlf

    call DisplayDecimalForm
    jmp  Done

BaseIsOne:
    mov  eax, 1
    jmp  DisplayIntegerResult

BaseIsNegativeOne:
    test ecx, 1
    jz   NegativeOneEven
    mov  eax, -1
    jmp  DisplayIntegerResult

NegativeOneEven:
    mov  eax, 1
    jmp  DisplayIntegerResult

DisplayDecimalForm PROC
    fild result
    fld1
    fdiv
    
    mov  edx, OFFSET msgDecimal
    call WriteString
    call WriteFloat
    call Crlf
    call Crlf
    
    fstp decimalResult
    ret
DisplayDecimalForm ENDP

OverflowDetected:
    mov  edx, OFFSET msgResultPow
    call WriteString
    mov  edx, OFFSET msgFraction
    call WriteString
    mov  eax, base
    call WriteInt
    mov  al, '^'
    call WriteChar
    mov  eax, exponent
    neg  eax
    call WriteInt
    call Crlf
    
    mov  edx, OFFSET msgDecimal
    call WriteString
    mov  edx, OFFSET msgOverflow
    call WriteString
    call Crlf
    jmp  Done

DisplayIntegerResult:
    mov  result, eax
    mov  edx, OFFSET msgResultPow
    call WriteString
    call WriteInt
    call Crlf

Done:
    ret
PowerCalculation ENDP

; ---------------- DIVISION ----------------
DivisionOperation PROC

    mov edx, OFFSET msgDividend
    call WriteString
    call ReadInt
    mov ebx, eax

    mov edx, OFFSET msgDivisor
    call WriteString
    call ReadInt
    mov ecx, eax

    cmp ecx, 0
    jne PerformDivision
    
    mov edx, OFFSET msgError
    call WriteString
    call Crlf
    ret

PerformDivision:
    mov eax, ebx
    cdq
    idiv ecx

    mov quotient, eax
    mov remainder, edx

    mov edx, OFFSET msgQuotient
    call WriteString
    mov eax, quotient
    call WriteInt
    call Crlf

    mov edx, OFFSET msgRemainder
    call WriteString
    mov eax, remainder
    call WriteInt
    call Crlf

    ret
DivisionOperation ENDP

; ---------------- NPR ----------------
Factorial PROC
    push ecx
    mov eax, 1
    
    cmp ecx, 0
    je FactorialDone
    
FactorialLoop:
    imul ecx
    loop FactorialLoop

FactorialDone:
    pop ecx
    ret
Factorial ENDP

PermutationCalculation PROC

    mov edx, OFFSET msgN
    call WriteString
    call ReadInt
    mov n_value, eax

    mov edx, OFFSET msgR
    call WriteString
    call ReadInt
    mov r_value, eax

    mov ebx, n_value
    cmp eax, ebx
    jle CalculatePermutation
    
    mov edx, OFFSET msgErrorNPR
    call WriteString
    call Crlf
    ret

CalculatePermutation:
    mov ecx, n_value
    call Factorial
    mov ebx, eax

    mov eax, n_value
    sub eax, r_value
    mov ecx, eax
    call Factorial

    mov eax, ebx
    mov edx, 0
    div ecx

    mov resultNPR, eax
    mov edx, OFFSET msgResultNPR
    call WriteString
    call WriteDec  
    call Crlf

    ret
PermutationCalculation ENDP

END main
